import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Исходные данные для моделирования
# Нихром
# Параметры (по паспотным данным)
N_P = 1500  # Мощность нагревателя, Вт. (выбираем пока примерно для моделирования,
# считаем, что вся электрическая мощность уходит в тепловую)
N_rho = 1.1  # Удельное сопротивление нихрома, Ом*мм2/м (подбираем)
N_d = 0.8  # Диаметр нихромовой проволки, мм (подбираем)

N_U = 220  # Действующее напряжение сети, В (которое подаем на нагреватель)(синусоидальность напряжения рассматривать не будем,
# в силу того, что электрические процессы гораздо быстрее рассматриваемых
# тепловых, и моделирование приследует цели инженерных расчетов)
N_R = N_U ** 2 / N_P  # Сопротивление нагревателя, Ом (высчитываем относительно проектируемой мощности)
N_S = np.pi * N_d ** 2 / 4  # Площадь сечения нихромовой спирали, мм2 (высчитываем)
N_L = N_R * N_S / N_rho  # Требуемая длина нихромовой спирали, м (высчитываем) (такая длина, нам теоретически нужна,
# чтобы обеспечить тепловую мощность в 1кВт относительно выбранного
# нихромового провода)

N_c = 450  # Удельная теплоемкость нихрома, Дж/(кг*С) (по физическим свойствам)
N_ro = 8300  # Плотность нихрома, кг/м3 (по физическим свойствам)

N_m = N_ro * N_L * N_S / 1e6  # Масса нихромовой спирали, кг (расчитываем)
N_F = np.pi * N_d / 1e3 * N_L  # Контактная площадь спирали, м2

# Воздух
# Табличные данные
A_c = 1000  # Теплоемкость воздуха, Дж/(кг*С)
A_ro = 1.2  # Плотность воздуха, кг/м3
A_m = A_ro * np.pi * (0.1) ** 2 / 4 * (2)  # Масса воздуха, кг (приблизительно, при условии
# что воздуха прокачивается через 2м трубу сечением 0,1м


alf = 250  # Коэффициент теплопередачи нихром - воздух, Вт/(м2*С)

# Электрическая часть (двигатель вентилятора)
# Параметры определены как приблизительные, обеспечивающие схожее с
# реальным поведение модели
U = 220  # Напряжение подаваемое на вентилятор, В (Можно менять для изменения расхода воздуха)
# изменяемый расход можно исопльзовать как возмущающее воздействие
L = 1  # Индуктивность обмотки двигателя, Гн
R = 100  # Активное сопротивление обмотки двигателя, Ом
kw = 1  # Коэффициент скорости, отн.
ke = 9  # Коэффициент самоиндукции, отн.
kc = 0.037  # Коэффициент сопротивления, отн.
# Коэффициенты подбирались приблизительно
J = 0.1  # Момент инерции, кг*м2

# Характеристики вентилятора
Gnom = 200 / 3600  # Номинальный расход, м3/с
wnom = 1500 / 9.54929658551369  # Номинальная частота вращения, рад/с

# Параметры моделирования
dt = 0.01  # Дискрет времени, с
t_end = 30  # Общее время моделирования, с
t = np.arange(0, t_end + dt, dt)  # Создание массива временных шагов от 0 до t_end с шагом dt

df_rez = pd.DataFrame(columns=['discrepancy', 'T_a', 'U_reg', 'target', 'T_a_in', 'delta_U'])  # Создание таблицы
hh = []


for _ in range(100):
    # Начальтные условия моделирования, для численного интегрирования
    T_a_in = np.random.uniform(-20, 30)  # Температура окружающего воздуха, С
    T_a = np.zeros(len(t))
    T_a[0] = T_a_in
    T_n = np.zeros(len(t))
    T_n[0] = T_a_in
    i = np.zeros(len(t))
    i[0] = 0
    w = np.zeros(len(t))
    w[0] = 0
    G_ = np.zeros(len(t))
    G_[0] = 0

    target = T_a_in + np.random.uniform(1, 11)

    discrepancy = np.zeros(len(t))
    discrepancy[0] = T_a[0] - target

    U_reg = np.zeros(len(t))
    U_reg[0] = np.random.uniform(0, 220)  # Напряжение подаваемое на нагреватель (ЕГО МЕНЯЕМ РЕГУЛЯТОРОМ)

    delta_U = np.zeros(len(t))
    delta_U[0] = 0

    for j in range(int(t_end / dt)):
        # Уравнения электродвигателя, считаем ток и обороты
        i[j + 1] = i[j] + dt * (1 / L * (U - kw * w[j] - i[j] * R))
        w[j + 1] = w[j] + dt * (1 / J * (ke * i[j] - kc * w[j]))
        # Считаем расход воздуха относительно оборотов
        G_[j + 1] = Gnom * (w[j + 1] / wnom)
        # Уравнения теплопередачи
        T_n[j + 1] = T_n[j] + dt * (1 / (N_c * N_m) * (U_reg[j] ** 2 / N_R - alf * N_F * (T_n[j] - T_a[j])))
        T_a[j + 1] = T_a[j] + dt * (1 / (A_c * A_m) * (alf * N_F * (T_n[j] - T_a[j]) - 2 * G_[j + 1] * A_ro * A_c * (T_a[j] - T_a_in)))
        discrepancy[j + 1] = T_a[j + 1] - target

        if discrepancy[j + 1] < 0:
            delta_U[j + 1] = np.random.uniform(0, 1)
            U_reg[j + 1] = U_reg[j] + delta_U[j + 1]
        elif discrepancy[j + 1] > 0:
            delta_U[j + 1] = np.random.uniform(-1, 0)
            U_reg[j + 1] = U_reg[j] + delta_U[j + 1]
        else:
            pass

    current_df = pd.DataFrame({
        'T_a': T_a,
        'U_reg': U_reg,
        'target': [target] * len(T_a),
        'T_a_in': [T_a_in] * len(T_a),
        'delta_U': delta_U
    })
    df_rez = pd.concat([df_rez, current_df], ignore_index=True)  # Прсоединение данных к таблице

    # plt.figure(1)
    # plt.plot(t, T_a, t, [target] * len(t))
    # plt.grid(True)
    # plt.legend(['T_a', 'target'])
    #
    # plt.show()



df_rez.to_csv(f'rez.csv', index=False)  # Сохранение таблицы в файл



