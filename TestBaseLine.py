import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential, load_model
import joblib
import warnings
import os


warnings.filterwarnings('ignore')
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Исходные данные для моделирования
# Нихром
# Параметры (по паспотным данным)
N_P = 1500  # Мощность нагревателя, Вт. (выбираем пока примерно для моделирования,
# считаем, что вся электрическая мощность уходит в тепловую)
N_rho = 1.1  # Удельное сопротивление нихрома, Ом*мм2/м (подбираем)
N_d = 0.8  # Диаметр нихромовой проволки, мм (подбираем)

N_U = 220  # Действующее напряжение сети, В (которое подаем на нагреватель)(синусоидальность напряжения рассматривать не будем,
# в силу того, что электрические процессы гораздо быстрее рассматриваемых
# тепловых, и моделирование приследует цели инженерных расчетов)
N_R = N_U ** 2 / N_P  # Сопротивление нагревателя, Ом (высчитываем относительно проектируемой мощности)
N_S = np.pi * N_d ** 2 / 4  # Площадь сечения нихромовой спирали, мм2 (высчитываем)
N_L = N_R * N_S / N_rho  # Требуемая длина нихромовой спирали, м (высчитываем) (такая длина, нам теоретически нужна,
# чтобы обеспечить тепловую мощность в 1кВт относительно выбранного
# нихромового провода)

N_c = 450  # Удельная теплоемкость нихрома, Дж/(кг*С) (по физическим свойствам)
N_ro = 8300  # Плотность нихрома, кг/м3 (по физическим свойствам)

N_m = N_ro * N_L * N_S / 1e6  # Масса нихромовой спирали, кг (расчитываем)
N_F = np.pi * N_d / 1e3 * N_L  # Контактная площадь спирали, м2

# Воздух
# Табличные данные
A_c = 1000  # Теплоемкость воздуха, Дж/(кг*С)
A_ro = 1.2  # Плотность воздуха, кг/м3
A_m = A_ro * np.pi * (0.1) ** 2 / 4 * (2)  # Масса воздуха, кг (приблизительно, при условии
# что воздуха прокачивается через 2м трубу сечением 0,1м


alf = 250  # Коэффициент теплопередачи нихром - воздух, Вт/(м2*С)

# Электрическая часть (двигатель вентилятора)
# Параметры определены как приблизительные, обеспечивающие схожее с
# реальным поведение модели
U = 220  # Напряжение подаваемое на вентилятор, В (Можно менять для изменения расхода воздуха)
# изменяемый расход можно исопльзовать как возмущающее воздействие
L = 1  # Индуктивность обмотки двигателя, Гн
R = 100  # Активное сопротивление обмотки двигателя, Ом
kw = 1  # Коэффициент скорости, отн.
ke = 9  # Коэффициент самоиндукции, отн.
kc = 0.037  # Коэффициент сопротивления, отн.
# Коэффициенты подбирались приблизительно
J = 0.1  # Момент инерции, кг*м2

# Характеристики вентилятора
Gnom = 200 / 3600  # Номинальный расход, м3/с
wnom = 1500 / 9.54929658551369  # Номинальная частота вращения, рад/с

# Параметры моделирования
dt = 0.01  # Дискрет времени, с
t_end = 30  # Общее время моделирования, с
t = np.arange(0, t_end + dt, dt)  # Создание массива временных шагов от 0 до t_end с шагом dt


# Начальтные условия моделирования, для численного интегрирования
T_a_in = np.random.uniform(-20, 30)  # Температура окружающего воздуха, С
T_a = np.zeros(len(t))
T_a[0] = T_a_in
T_n = np.zeros(len(t))
T_n[0] = T_a_in
i = np.zeros(len(t))
i[0] = 0
w = np.zeros(len(t))
w[0] = 0
G_ = np.zeros(len(t))
G_[0] = 0

target = T_a_in + np.random.uniform(1, 11)

discrepancy = np.zeros(len(t))
discrepancy[0] = T_a[0] - target

U_reg = np.zeros(len(t))
U_reg[0] = np.random.uniform(0, 220)  # Напряжение подаваемое на нагреватель (ЕГО МЕНЯЕМ РЕГУЛЯТОРОМ)

delta_U = np.zeros(len(t))
delta_U[0] = 0

# Загрузка скалера
scaler = joblib.load('scaler.joblib')
# Загрузка модели
model = load_model('modelBase.h5')


for j in range(int(t_end / dt)):
    # Уравнения электродвигателя, считаем ток и обороты
    i[j + 1] = i[j] + dt * (1 / L * (U - kw * w[j] - i[j] * R))
    w[j + 1] = w[j] + dt * (1 / J * (ke * i[j] - kc * w[j]))
    # Считаем расход воздуха относительно оборотов
    G_[j + 1] = Gnom * (w[j + 1] / wnom)
    # Уравнения теплопередачи
    T_n[j + 1] = T_n[j] + dt * (1 / (N_c * N_m) * (U_reg[j] ** 2 / N_R - alf * N_F * (T_n[j] - T_a[j])))
    T_a[j + 1] = T_a[j] + dt * (1 / (A_c * A_m) * (alf * N_F * (T_n[j] - T_a[j]) - 2 * G_[j + 1] * A_ro * A_c * (T_a[j] - T_a_in)))
    discrepancy[j + 1] = T_a[j + 1] - target
    delta_U[j+1] = np.random.uniform(0, 1)
    example = np.array([[discrepancy[j + 1], T_a[j + 1], U_reg[j], target, T_a_in]])  # Пример входных данных
    example_scaled = scaler.transform(example)
    predicted_delta_U = model.predict(example_scaled, verbose=0)
    U_reg[j + 1] = U_reg[j] + predicted_delta_U





plt.figure(1)
plt.plot(t, T_a, t, [target] * len(t))
plt.grid(True)
plt.legend(['T_a', 'target'])

plt.show()







